# Executors

## Пререквизиты

- [fibers/coroutine](/tasks/fibers/coroutine)

## Декомпозиция

_Stackful файберы_, _фьючи_, _stackless корутины_ – это _выразительные средства_, с помощью которых разработчик описывает конкурентные активности в своем коде.

Для разработчика, который ими пользуется, эти средства существенно отличаются друг от друга. А для _среды исполнения_ (пула потоков) они, наоборот, выглядят одинаково – как цепочки неблокирующихся задач.

Конкурентность в нашем дизайне декомпозирована:
- _Выразительные средства_ описывают цепочки задач
- _Среда исполнения_ исполняет эти цепочки

## Абстракция

В этой задаче мы абстрагируем среду исполнения: файберы, фьючи и корутины будут запускать свои задачи не в пуле потоков, а в абстрактном _экзекуторе_.

## Executor

_Executors are to function execution as allocators are to memory allocation_

_Экзекутор_ (_executor_) – это сервис, исполняющий задачи. 

Экзекутор реализует интерфейс [`IExecutor`](exe/executors/executor.hpp) с единственным методом `Execute` – запланировать задачу на исполнение.

Единственная гарантия, которую экзекутор дает своему пользователю: запланированная в него задача будет выполнена.

В каком потоке и когда именно – зависит от конкретной реализации интерфейса `IExecutor`. Механика исполнения задач скрыта от пользователя за виртуальным вызовом.

## Дизайн

- _Выразительные средства_ (файберы, фьючи, корутины) описывают _что_ исполнять
- _Экзекуторы_ (`ThreadPool`, `ManualExecutor`, `Strand`) – _как_ исполнять
- `IExecutor` – граница, разделяющая выразительные средства и конкретные стратегии исполнения задач

## Примеры

### Пул потоков

[`ThreadPool`](exe/executors/tp/compute/thread_pool.hpp) – статический набор потоков, разбирающих общую очередь задач.

```cpp
void ThreadPoolExample() {
  using namespace exe;
  
  // ThreadPool реализует интерфейс IExecutor
  // Вместо метода Submit у него теперь Execute
  executors::ThreadPool pool{/*threads=*/4};
  
  executors::Execute(pool, []() {
    // Печатаем приветствие из потока пула
    std::cout << "Hi!" << std::endl;
  });
  
  // Дожидаемся завершения всех задач
  pool.WaitIdle();
  // Останавливаем пул
  pool.Stop();
}
```

#### Применение

Мы уже использовали пул потоков как планировщик для файберов:

```cpp
void FibersExample() {
  using namespace exe;
  
  executors::ThreadPool pool{4};

  // Функция Go теперь принимает IExecutor&
  fibers::Go(/*executor=*/pool, []() {
    for (size_t i = 0; i < 7; ++i) {
      fibers::self::Yield();
    }
  });
  
  pool.WaitIdle();
  pool.Stop();
}
```

Класс `Fiber` не знает в каком именно экзекуторе его запустили.

Реализация файберов должна полагаться только на абстракцию `IExecutor` и на базовую гарантию, которую она предоставляет.


### Manual

[`ManualExecutor`](exe/executors/manual.hpp) – это всего лишь очередь задач.

Вызов `Execute` добавляет задачу в конец этой очереди.

Задачи, запланированные в `ManualExecutor`, запускаются _вручную_ с помощью методов `RunNext`, `RunAtMost` и `Drain`.

С `ManualExecutor` должен работать только один поток. Собственных потоков у `ManualExecutor` нет.

#### Пример

```cpp
void ManualExample() {
  using namespace exe;
  
  // ManualExecutor – очередь задач
  executors::ManualExecutor manual;
  
  // Добавляем задачу в очередь
  executors::Execute(manual, []() {
    std::cout << "Task 1" << std::endl;
  });
  
  // И еще одну
  executors::Execute(manual, []() {
    std::cout << "Task 2" << std::endl;
  });

  // <-- Теперь обе задачи находятся в очереди ManualExecutor-а,
  // пока ни одна из них не была запущена

  // Запустим первую задачу
  manual.RunNext();

  // Запланируем третью задачу
  executors::Execute(manual, []() {
    std::cout << "Task 3" << std::endl;
  });

  // "Опустошаем" очередь задач, т.е.
  // исполняем задачи до тех пор, пока очередь не опустеет
  manual.Drain();
  // <-- К этому моменту выполнились все три задачи
}
```

#### Применение

С помощью `ManualExecutor` файберы можно исполнять детерминированно, по шагам, что может быть очень удобно для тестирования:

```cpp
void ManualFibers() {
  using namespace exe;
  
  // "Ручной" планировщик
  executors::ManualExecutor scheduler;
  
  fibers::Go(scheduler, []() {
    std::cout << "Step 1" << std::endl;
    fibers::self::Yield();
    std::cout << "Step 3" << std::endl;
  });

  fibers::Go(scheduler, []() {
    std::cout << "Step 2" << std::endl;
    fibers::self::Yield();
    std::cout << "Step 4" << std::endl;
  });
  
  // <-- Пока ни один файбер не начал исполняться
  
  // Первый шаг первым файбером
  scheduler.RunNext();
  // <-- Первый файбер зашел в `Yield`
  
  // Первый шаг вторым файбером
  scheduler.RunNext();
  // <-- Второй файбер зашел в `Yield`
  
  scheduler.Drain();
}
```

Вносить изменения в файберы при этом не требуется!

### Strand

#### Проблема

Задачам в пуле потоков может понадобиться взаимное исключение.

Использовать мьютексы нежелательно: если задача в пуле захватила мьютекс на продолжительное время, то другие задачи, которым нужен этот же мьютекс, заблокируют потоки пула и помешают исполняться даже тем задачам, которым мьютекс вообще не нужен.

#### Асинхронный мьютекс

Экзекуторы предоставляют альтернативу: _асинхронный мьютекс_ или `Strand`.

[`Strand`](exe/executors/strand.hpp) – экзекутор, запускающий задачи (можно назвать их критическими секциями) строго _последовательно_, в порядке их планирования (вообще говоря, этот порядок частичный – _happens-before_).

Планировать задачи в `Strand` можно одновременно из разных потоков.

#### Декоратор

`Strand` не имеет собственных потоков. `Strand` – декоратор, он оборачивает произвольный экзекутор и делегирует исполнение задач ему.

`Strand` не делает никаких предположений об устройстве декорируемого экзекутора. Единственная гарантия, на которую `Strand` полагается, – каждая запланированная
в декорируемый экзекутор задача однажды будет выполнена.

Один и тот же пул потоков могут использовать для исполнения произвольное число `Strand`-ов.

#### Пример

```cpp
void StrandExample() {
  using namespace exe::executors;
  
  // Потоки, исполняющие задачи
  ThreadPool workers{4};
  // Декоратор над пулом потоков `workers`
  // Сам `strand` не знает, что он декорирует именно пул потоков
  Strand strand{workers};
  
  ThreadPool clients{5};
  
  size_t cs = 0;
  
  // Запускаем в пуле `clients` задачи, которые будут
  // параллельно планировать критические секции в `strand`
  
  for (size_t i = 0; i < 1024; ++i) {
    Execute(clients, [&]() {
      // Следующий `Execute` вызывается из разных потоков пула `clients`
      Execute(strand, [&]() {
        // Асинхронная критическая секция
        ++cs;
      });
    });
  }
  
  // Ждем завершения клиентов
  clients.WaitIdle();
  // Ждем завершения секций
  workers.WaitIdle();
  
  std::cout << "# critical sections: " << cs << std::endl;
  // <-- Напечатано 1024
  
  clients.Stop();
  workers.Stop();
}
```

#### `Strand` и мьютекс

##### Мьютекс

С точки зрения протокола когерентности кэшей, синхронный мьютекс – неэффективный примитив синхронизации:

Чем больше число ядер / потоков, исполняющих критические секции, тем выше накладные расходы на когерентность, так как разделяемые данные, к которым обращаются критические секции, придется постоянно двигать между ядрами.

##### Strand

Гораздо разумнее не данные двигать к критическим секциям на разные ядра, а наоборот – критические секции перенести на одно ядро.

Чем больше нагрузка на `Strand`, тем _меньше_ будет в исполнении синхронизации, и тем эффективнее будут исполняться критические секции пользователей (в отличие от обычного мьютекса, в котором все наоборот)!

## Задание

1) Перенесите в [`ThreadPool`](exe/executors/tp/compute/thread_pool.hpp) реализацию пула потоков
2) Реализуйте [`ManualExecutor`](exe/executors/manual.hpp)
3) Реализуйте [`Strand`](exe/executors/strand.hpp) используя взаимное исключение
4) Реализуйте [`Strand`](exe/executors/strand.hpp) через лок-фри очередь 


## Реализация

### `Strand`

#### Серии

`Strand` должен исполнять задачи _сериями_ или _пакетами_ (_batching_).

1) Серийность позволит избавиться от синхронизации между критическими секциями при исполнении серии.
2) Критические секции внутри серии будут работать над прогретым кэшом.

Серии должны адаптироваться под нагрузку:

- Чем больше нагрузка на `Strand`, тем больше должны быть серии, и тем меньше должно быть синхронизации в исполнении.
- При этом `Strand` не должен искусственно задерживать исполнение задач.

#### Lock-Free

Простая реализация `Strand` будет использовать взаимное исключение для доступа к очереди задач.

Избавьтесь от взаимного исключения: храните задачи `Strand`-а в лок-фри очереди. Вам пригодится умение строить очередь из двух стеков.

Продумайте управление памятью в вашей реализации.

Если вы все сделали правильно, то реализация лок-фри очереди для `Strand` получится очень простой.

### Интрузивность

Бонусный уровень!

Избавьтесь от динамических аллокаций памяти в экзекуторах, сделав задачи интрузивными. 

За аллокацию памяти для задачи должен отвечать пользователь экзекутора:
- Ни файберам, ни фьючам, ни stackless корутинам динамические аллокации при планировании задач не требуются.
- Для лямбд выполняйте динамическую аллокацию в функции [`Execute`](exe/executors/execute.hpp).

## Мьютекс для файберов

В этой задаче вы реализуете _асинхронный серийный лок-фри_ мьютекс.

А теперь вспомним, что файберы с помощью переключения контекста могут превращать асинхронные интерфейсы в синхронные.

Воспользуйтесь этим наблюдением и реализуйте для файберов _синхронный серийный лок-фри_ мьютекс в задаче [`fibers/mutex`](/tasks/fibers/mutex).
