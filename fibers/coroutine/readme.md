# Корутины

## Пререквизиты

- [condvar/thread-pool](/tasks/condvar/thread-pool)

---


_Сопрограмма_ или, менее формально, _корутина_ (_coroutine_) – это процедура,
из вызова которой можно выйти в середине, а затем вернуться в него
и продолжить исполнение.

_Сопрограмма_ расширяет понятие подпрограммы (_subroutine_): 
у подпрограммы одна точка входа и одна точка выхода, 
у сопрограммы их может быть несколько.

## `Coroutine`

Экземпляр класса `Coroutine` представляет вызов корутины,
который может остановиться (операция `Suspend`), и который затем можно
возобновить (операция `Resume`).

Создадим корутину:

```cpp
Coroutine co(routine);
```

Здесь `routine` – произвольная пользовательская процедура, которая будет исполняться корутиной `co`. Непосредственно создание корутины не приводит к запуску функции `routine`.

Созданная корутина запускается вызовом `co.Resume()`. После этого управление передается функции `routine`, и та исполняется до первого вызова `Suspend()` (или до своего завершения).

Вызов `Suspend()` в корутине останавливает ее исполнение, передает управление обратно caller-у и завершает его вызов `co.Resume()`. Вызов `Suspend()` – это точка выхода из корутины, _suspension point_.

Следующий вызов `co.Resume()` вернет управление остановленной корутине, вызов `Suspend()` в ней завершится, и она продолжит исполнение до очередного `Suspend()` или же до завершения своей процедуры.

С исключениями корутины взаимодействуют как обычные функции: если в корутине было выброшено и не перехвачено исключение, то оно вылетит в caller-е из вызова `co.Resume()` и полетит дальше (выше) по цепочке вызовов.

Код, исполняемый внутри корутины, не имеет доступа к самому объекту `Coroutine`. Чтобы остановить исполнение, корутина вызывает статический метод `Suspend`.

Для лучшего понимания API и потока управления в корутинах изучите [тесты](tests/coroutine/standalone/main.cpp) к задаче.

### Пример

```cpp
void BasicsExample() {
  using exe::coroutine::Coroutine;
  
  auto routine = []() {
    // Роль: callee

    std::cout << "Step 2" << std::endl;
    
    Coroutine::Suspend();  // <-- Suspension point

    std::cout << "Step 4" << std::endl;
  };

  // Роль: caller

  // Stackful корутина
  Coroutine co(routine);
  // <-- Исполнение процедуры `routine` пока не стартовало

  std::cout << "Step 1" << std::endl;

  // Стартуем корутину
  // Управление передается процедуре routine,
  // и та исполняется до первого вызова Suspend().
  co.Resume();

  std::cout << "Step 3" << std::endl;

  co.Resume();

  // Вызов IsCompleted() возвращает true если корутина уже завершила 
  // свое исполнение (дойдя до конца `routine` или бросив исключение).
  assert(co.IsCompleted());

  // Попытка вызова Suspend вне корутины - UB
  // Coroutine::Suspend()
}
```

На экране будет напечатано:
```
Step 1
Step 2
Step 3
```

### Stackful / Stackless

В этой задаче мы говорим про конкретный вид корутин – _stackful_: `Suspend` во вложенном вызове останавливает весь стек вызовов.

Такие корутины можно реализовать самостоятельно, в виде библиотеки.

Другой вид корутин – _stackless_: они умеют останавливаться только непосредственно в своей процедуре, не блокируя вызовы выше по стеку.

[Корутины в C++20](https://en.cppreference.com/w/cpp/language/coroutines) – stackless и реализованы на уровне языка, т.е. непосредственно в компиляторе.

## Применения корутин

### Асинхронность

Корутины – инструмент для выражения конкурентности и работы с асинхронностью в современных языках программирования.

В этой задаче с помощью корутин мы реализуем файберы – легковесные кооперативные потоки. 

### Итераторы

С помощью корутин можно писать итераторы по рекурсивным структурам данных: [Iteration Inside and Out](https://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/)

### Процессоры / генераторы

Процессоры и генераторы позволяют описывать конвейеры / графы обработки потоков данных.

#### Push

В _процессорах_ поток данных направлен от caller к callee:

```cpp
void ProcessorExample() {
  using namespace exe::coroutine::processors;
  
  Processor<std::string> consumer([]() {
    // Функция `Receive` останавливает исполнение процессора до
    // вызова caller-ом метода `Send`
    while (auto data = Receive<std::string>()) {
      std::cout << *data << std::endl;
    }
  });
  
  // Модель push
  
  // Посылаем процессору порции данных для обработки
  consumer.Send("Hello");
  // <-- На экране напечаталось `Hello`
  consumer.Send("World");
  // <-- На экране напечаталось `World`
  consumer.Close();
  // <-- Процедура `consumer`-а завершилась
}
```

Оригинальное применение корутин – реализация модульного компилятора, где каждый модуль представлен корутиной, и эти модули организованы в конвейер: [Design of a Separable Transition-Diagram Compiler](https://www.melconway.com/Home/pdf/compiler.pdf)

### Pull

В _генераторах_ поток данных направлен в обратную сторону, от callee к caller-у:

```cpp
void GeneratorExample() {
  using namespace exe::coroutine::generators;
  
  Generator<int> countdown([]() {
    for (int i = 10; i >= 0; --i) {
      Send(i);
    }
  });
  
  // Модель pull
  
  while (auto next = countdown.Receive()) {
    // next - std::optional
    std::cout << *next << std::end;
  }
  std::cout << "Launch!" << std::endl;
}
```

## От корутин к файберам

В этой задаче вы должны выразить файберы через корутины.

Планировщик для файберов вами [уже реализован](tasks/condvar/thread-pool) – это пул потоков, `ThreadPool`.

## Файберы

```cpp
void FibersExample() {
  // В этой задаче мы начнем писать свой 
  // фреймворк для concurrency
  // Он будет называться `exe` (от execution)
  using namespace exe;

  // Планировщиком для файберов будет служить пул потоков
  tp::ThreadPool scheduler{/*threads=*/4};

  for (size_t i = 0; i < 100500; ++i) {
    // Запускаем файбер в пуле-планировщике
    fibers::Go(scheduler, []() {
      for (size_t j = 0; j < 3; ++j) {
        // Уступаем поток планировщика другому файберу
        fibers::self::Yield();
      }  
    });
  }
  
  // Файберы исполняются _параллельно_ на разных потоках пула-планировщика

  // Дожидаемся завершения файберов
  scheduler.WaitIdle();
  // Выключаем планировщик
  scheduler.Stop();
}  
```

## Декомпозиция

Реализация многопоточных файберов свелась к комбинированию двух ортогональных компонентов:

- Пул потоков
- Stackful корутина

Пул потоков ничего не знает про природу задач, которые он исполняет.

Корутины ничего не знают про пулы потоков и кооперативную многозадачность, и могут быть использованы для реализации итераторов и генераторов.

### `Task`, `Coroutine`, `Fiber`

Чтобы лучше понять предложенную декомпозицию, подумайте как в реализации файберов будут распределены обязанности между сущностями _задача_ (`Task`), _корутина_ (`Coroutine`) и _файбер_ (`Fiber`).

### Фреймворк

Декомпозиция отражена в организации фреймворка `exe`, который мы начнем писать в этой задаче:
- [`coroutine`](exe/coroutine) – корутины 
- [`tp`](exe/tp) – пул потоков (планировщик)
- [`fibers`](exe/fibers) – файберы, зависят от `tp` и `coroutine`

## Корутины и файберы

И stackful корутины, и файберы – исполняемые сущности, которые могут останавливаться и затем возобновлять исполнение.
И корутины, и файберы используют механизм переключения контекста для нелокальной передачи управления.

Но стоит отличать их друг от друга!

### Файберы

Файберы – это кооперативная многозадачность: независимые конкурирующие друг с другом активности, чередующиеся на процессоре.

За исполнение файберов отвечает планировщик, его задача – распределять файберы между потоками (аналогично планировщику операционной системы, который распределяет потоки между ядрами процессора).

Файберы могут исполняться одновременно и переключаться с потока на поток.

Помимо планировщика, файберам нужны собственные средства синхронизации: мьютексы, кондвары, каналы и т.д.

### Корутины

Корутины гораздо ближе к обычным функциям, чем к файберам.

Прямого отношения к потокам и многозадачности корутины не имеют. Корутины не нуждаются в примитивах синхронизации. У корутин нет планировщика.

Управление передается от caller-а к callee и обратно через вызовы `Resume` и `Suspend`, как при вызове обычных функций.

## `CoroutineImpl`

Мы перечислили разные применения корутин: файберы, генераторы и т.п.

В нашем фреймворке они будут основаны на одной и той же реализации – [`CoroutineImpl`](exe/coroutine/impl.hpp).

`CoroutineImpl` не управляет стеками, он получает только _view_ на них (в виде [`MutableMemView`](https://gitlab.com/Lipovsky/wheels/-/blob/master/wheels/memory/view.hpp)), за управление памятью отвечает код уровнем выше (например, рантайм файберов).

`CoroutineImpl` имеет небезопасный / неудобный `Suspend`: пользователь должен сам найти объект корутины и вызвать метод прямо на нем. 

### `ExecutionContext`

Корутина (в виде `CoroutineImpl`) – исполняемая сущность, а значит у нее должен быть собственный контекст исполнения, который представлен классом [`ExecutionContext`](https://gitlab.com/Lipovsky/context/-/blob/master/context/context.hpp).

`ExecutionContext` поддерживает две операции: _установка_ (`Setup`) и _переключение_ (`SwitchTo`) контекста.

#### Переключение контекста

Выглядит так: `current.SwitchTo(target)`

Текущий контекст исполнения на процессоре будет сохранен в `current`, после чего на процессоре активируется контекст `target`.

#### Установка контекста

В позиции `target` в переключении контекста может находиться либо контекст, который ранее был сохранен с помощью `SwitchTo` (т.е. находился слева от вызова), 
либо который был сконструирован "вручную" с помощью метода `Setup`.

Метод `ExecutionContext::Setup` принимает два аргумента:
- `stack` – диапазон памяти для стека, на котором будет работать новое исполнение, в виде `MutableMemView`
- `trampoline` – указатель на реализацию интерфейса [`ITrampoline`](https://gitlab.com/Lipovsky/context/-/blob/master/context/trampoline.hpp) с единственным методом `Run`.

После переключения через `SwitchTo` в установленный через `Setup` контекст исполнение начнется с вызова `trampoline->Run()` на стеке `stack`.

Пример использования: [TinyFibers](https://gitlab.com/Lipovsky/tinyfibers/-/blob/master/tinyfibers/core/fiber.cpp)

#### `ExitTo`

При последнем переключении из контекста корутины / файбера (т.е. в конце трамплина) используйте [`ExitTo`](https://gitlab.com/Lipovsky/context/-/blob/f51d01b54a529b445f1be51eae515629ba8c8001/context/context.hpp#L43) вместо `SwitchTo`.
 
Этот граничный случай необходим для корректной работы проверок в [AddressSanitizer](https://clang.llvm.org/docs/AddressSanitizer.html).

## Задание

1) Реализуйте [`ThreadPool`](exe/tp/thread_pool.hpp)
2) Реализуйте [`CoroutineImpl`](exe/coroutine/impl.hpp)
3) Через `ThreadPool` и `CoroutineImpl` выразите [файберы](exe/fibers/core/api.hpp)

Бонусные уровни:
- Реализуйте [`Processor<T>`](exe/coroutine/processor.hpp)
- Реализуйте [`Generator<T>`](exe/coroutine/generator.hpp)

## Замечания по реализации

### Исключения

Используйте [std::exception_ptr](https://en.cppreference.com/w/cpp/error/exception_ptr) для прокидывания исключения из корутины в caller-а.

### Стеки

Класс `CoroutineImpl` получает лишь _view_ стека, он сам не аллоцирует и не управляет памятью.

За управление ресурсами отвечает код уровнем выше.

Например, `Coroutine`, которая используется в тестах, просто аллоцирует новый стек в конструкторе и освобождает его в деструкторе.

Для файберов реализуйте [`StackAllocator`](exe/fibers/core/stacks.cpp), который переиспользует стеки завершившихся файберов.

Не аллоцируйте стеки в критической секции.

### Время жизни файбера

Аллоцируйте файберы на куче.

Не используйте умные указатели для контроля времени жизни файбера. Такой подход не будет сочетаться
с очередями ожидания в примитивах синхронизации, которые появятся в будущих задачах.

[Is it legal (and moral) for a member function to say `delete this`?](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)

### Интрузивность и `tp::Submit`

Будем считать, что все пользователи, запускающие в пуле потоков лямбды, пользуются не методом 
 `Submit`, а свободной функцией `tp::Submit`:

```cpp
void SubmitExample() {
  using namespace exe;
  
  tp::ThreadPool pool{4};
  
  tp::Submit(pool, []() {
    std::cout << "Hello!" << std::endl;
  });
  
  pool.WaitIdle();
  pool.Stop();
}
```

В тестах задачи в пул потоков планируются _только_ с помощью `tp::Submit`.

Сигнатуру метода `ThreadPool::Submit` допускается менять. Благодаря этому в файберах можно избавиться от всех аллокаций при 
планировании.

### `ThreadPool::Current`

Не используйте `ThreadPool::Current`, вместо этого храните указатель на пул потоков прямо в полях файбера.

В будущем мы обобщим пул потоков до абстрактного планировщика, и тогда аналогичный метод написать / использовать уже не получится.

### Misc

Не добавляйте в публичный интерфейс класса `CoroutineImpl` служебные методы, которые пользователь корутины не должен вызывать напрямую.

Не используйте `ThreadLocalPtr` в `CoroutineImpl`.

Класс `Fiber` не должен быть виден пользователю через публичное API.

## Полезные ссылки

- [Gor Nishanov – C++ Coroutines – a negative overhead abstraction](https://www.youtube.com/watch?v=Ts-1mWBmTNE)
- [Ron Pressler and Alan Bateman – Project Loom](https://www.youtube.com/watch?v=J31o0ZMQEnI)
- [Roman Elizarov – Introduction to Coroutines](https://www.youtube.com/watch?v=_hfBv0a09Jc)
