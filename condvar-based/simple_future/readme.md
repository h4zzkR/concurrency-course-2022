# Future

Напишите аналог [`std::future`](https://en.cppreference.com/w/cpp/thread/future).

## Blocking Futures

Пара `Future<T>` + `Promise<T>` образует "канал" для возврата результата из асинхронной операции.

_Результат_ – значение типа `T` или исключение.

`Promise<T>` – конец канала для записи, предоставляет два метода: `SetValue` для передачи значения и `SetException` для передачи исключения.

`Future<T>` – конец канала для чтения, предоставляет единственный метод `Get`, который блокирует поток до тех пор, пока через `Promise` не будет отправлен результат.  

Канал – одноразовый: вызвать `SetValue` / `SetException` на `Promise` и `Get` на `Future` можно только один раз, в противном случае – UB.  

Другая интерпретация: 

Пара `Future<T>` + `Promise<T>` образует контракт: поток-_producer_ обязуется выполнить контракт, передав потоку-_consumer_-у либо значение, либо возникшую ошибку.

### Пример

```cpp
// Пул потоков для вычислений
tp::ThreadPool pool{/*workers=*/4};

// Создаем "канал" или "контракт"
stdlike::Promise<int> p;
auto f = p.MakeFuture();

pool.Submit([p = std::move(p)]() mutable {
  std::this_thread::sleep_for(3s);  // <-- Тут можно представить тяжелое вычисление
  p.SetValue(42);  // <-- "Возвращаем" значение, "исполняем контракт"
});

int value = f.Get();  // <-- Дожидаемся значения
```

### Lifetimes 

Поток-_consumer_ может не дожидаться значения на `Future`, вообще не вызывать метод `Get`. Так что `Future` может разрушиться до того, как поток-_producer_ отправил результат через `Promise`.

Поток-_producer_ может отправить результат и разрушить `Promise` до того, как поток-_consumer_ вызовет `Get` на `Future`.

## Disclaimer

В этой задаче мы рассматриваем только наивные блокирующие фьючи, в том виде, в котором они представлены в `std`.

## Указания по реализации

Используйте [`std::variant`](https://en.cppreference.com/w/cpp/utility/variant) для представления результата (значения / исключения)

Используйте [`std::exception_ptr`](https://en.cppreference.com/w/cpp/error/exception_ptr) для того, чтобы переносить исключения между потоками.

В этой задаче вы можете создавать новые файлы в библиотеке `futures`.

Дополнительные классы, которые пользователь не должен использовать напрямую, спрячьте во вложенное пространство имен `stdlike::detail`.

### `void` vs `std::monostate`

Для `T` = `void` потребуется специализация шаблона:
- метод `void SetValue(T)` у `Promise` нужно заменить на `void Set()`, 
- а `T Get()` у `Future` – на `void Wait()`. 

Мы проигнорируем эту сложность и в качестве альтернативы будем использовать `T` = [`std::monostate`](https://en.cppreference.com/w/cpp/utility/variant/monostate) (_unit_-тип, тип с единственным значением). 