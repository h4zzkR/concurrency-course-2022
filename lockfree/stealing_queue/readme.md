# Work-Stealing Queue

Реализуйте [`WorkStealingQueue`](work_stealing_queue.hpp), которая послужит локальной очередью задач для потоков-воркеров [шардированного планировщика](/tasks/fibers/scheduler). 

Очередь реализована через циклический буфер. Емкость очереди / размер буфера задается через параметр шаблона.

Очередь хранит указатели на данные, а не сами данные.

## Операции

- `bool TryPush(T* item)` – если в очереди есть свободные слоты, то добавить в хвост очереди новый элемент и вернуть `true`. Если буфер очереди переполнился, то вернуть `false`.
- `T* TryPop()` – извлечь элемент (указатель) из головы очереди. Если очередь пуста, то вернуть `nullptr`.
- `size_t Grab(std::span<T*> out_buffer)` – забрать пачку элементов из головы очереди, переложив их в `out_buffer`, вернуть число извлеченных элементов.

Метод `Grab` представлен в API потому что он реализуется эффективнее, чем серия `TryPop`.

## Паттерн доступа

Паттерн доступа – вариация _Single Producer_ / _Multiple Consumers_:
- Метод `TryPush` и `TryPop` вызывает только один выделенный поток. 
- Метод `Grab` может вызываться конкурентно (с другими `Grab` и `TryPop` / `TryPush`) из нескольких потоков.

В планировщике
- Метод `TryPush` и `TryPop` использует поток-воркер, владеющий очередью. 
- Метод `Grab` используется 
  * другими воркерами для воровства задач, 
  * самим воркером для выгрузки задач в общую очередь при переполнении локальной.

## Требования

- Lock-freedom
- Установите в реализации оптимальные `memory_order`-ы.
